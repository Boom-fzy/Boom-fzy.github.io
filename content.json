[{"title":"JAVA虚拟机-JVM学习随笔","date":"2021-04-26T12:59:45.000Z","path":"2021/04/26/study-JVM/","text":"JVM内存结构首先jvm结构分三部分：类装载器子系统，运行时数据区，执行引擎Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。每个区域都有各自的作用 运行时数据区程序寄存器、Java虚拟机栈、Java堆、方法区、运行时常量池、本地方法栈等 程序寄存器每个线程都拥有一个程序寄存器，是线程私有的，用来存储指向下一条指令的地址在创建线程的时候，创建相应的程序寄存器执行本地方法时，程序寄存器的值为 undefined是一块比较小的内存空间，是唯一一个在JVM规范中没有规定 OutOfMemoryError 的内存区域 Java栈栈由一系列帧（栈帧）（Frame）组成（因此Java栈也叫做帧栈），是线程私有的栈帧用来保存一个方法的局部变量、操作数栈（Java没有寄存器，所有参数传递使用操作数栈）、常量池指针、动态链接、方法返回等每一次方法调用创建一个帧，并压栈，退出方法的时候，修改栈顶指针就可以把栈帧中的内容销毁局部变量表存放了编译期可知的各种基本数据类型和引用类型，每个 slot 存放32位的数据，long、double、占两个槽位栈的优点： 存取速度比堆块，仅次于寄存器栈的缺点：存在栈中的数据大小、生存区是在编译器决定的，缺乏灵活性 Java堆用来存放应用系统创建的对象和数组，所有线程共享 Java 堆GC主要管理堆空间，对分代GC来说，堆也是分代的堆的优点：运行期动态分配内存大小，自动进行垃圾回收；堆的缺点：效率相对较慢 方法区方法区是线程共享的，通常用来保存装载的类的结构信息通常和元空间关联在一起，但具体的跟JVM实现和版本有关JVM规范把方法区描述为堆的一个逻辑部分，但它有一个别名称为 Non-heap（非堆），应是为了与 Java 堆分开 运行时常量池是Class文件中每个类或接口的常量池表，在运行期间的表示形式，通常包括：类的版、字段、方法、接口等信息在方法区中分配通常在加载类和接口到JVM后，就创建相应的运行时常量池 本地方法栈在 JVM 中用来支持 native 方法执行的栈就是本地方法栈 GC 常用参数123456789101112131415161718192021-Xmn 年轻代-Xms 最小堆-Xmx 最大堆-Xss 栈空间-XX:+UseTLAB 使用TLAB(本地线程分配缓冲区)，默认打开-XX:+PrintTLAB 打印TLAB的使用情况-XX:TLABSize 设置TLAB大小-XX:+DisableExplictGC 禁用System.gc()不管用，防止FGC-XX:+PrintGC 打印GC日志-XX:+PrintGCDetails 打印GC详细日志信息-XX:+PrintHeapAtGC 打印GC前后的详细堆栈信息-XX:+PrintGCTimeStamps 打印时间戳-XX:+PrintGCApplicationConcurrentTime 打印应用程序时间-XX:+PrintGCApplicationStoppedTime 打印暂停时长-XX:+PrintReferenceGC 记录回收了多少种不同引用类型的引用-verbose:class 类加载详细过程-XX:+PrintVMOptions JVM参数-XX:+PrintFlagsFinal 查看JVM所有参数值-XX:+PrintFlagsInital 查看JVM参数启动的初始值-Xloggc:opt&#x2F;log&#x2F;gc.log GC日志的路径以及文件名称-XX:MaxTenuringThreshold 升代年龄，最大值15 垃圾收集器组合选择 单CPU或小内存，单机程序 -XX:+UseSerialGC 多CPU，需要最大吞吐量，如后台计算型应用 -XX:+UseParallelGC -XX:+UseParallelOldGC 多CPU，追求低停顿时间，需快速响应如互联网应用 -XX:+UseConcMarkSweepGC -XX:+ParNewGC table th:nth-of-type(5) { width: 80px; } table th:nth-of-type(4) { width: 220px; } table th:nth-of-type(1) { width: 184px; } 参数 新生代垃圾收集器 新生代算法 老年代垃圾收集器 老年代算法 -XX:+UseSerialGC SerialGC 复制 SerialOldGC 标记-整理 -XX:+UseParallelGC ParNew 复制 SerialOldGC 标记-整理 -XX:+UseParallelGC-XX:UseParallelOldGC Parallel[Scavenge] 复制 SerialOldGC 标记-整理 -XX:+UseConcMarkSweepGC ParNew 复制 SerialOldGC 标记-整理 -XX:+UseG1GC G1整体上采用标记-整理算法 局部通过复制算法，不会产生内存碎片 CMS+SerialOldGC的收集器组合，SerialOldGC作为CMS出错的后备垃圾收集器 标记-清除 系统CPU经常100%，如何调优CPU100%，那肯定是有线程一直在占用着系统资源，所以具体方法如下： 1、找出哪个进程cpu占用高 (top 命名)2、该进程中的哪个线程cpu占用高 (top -Hp $pid 命令)3、将十进制的tid转化为十六进制 (printf %x $tid 命令)4、导出该线程的堆栈 (jstack $pid &gt; $pid.log 命令)5、查找哪个方法(栈帧)消耗时间 (less $pid.log)6、可以确认工作线程占比高还是垃圾回收线程占比高7、修改代码 实际调优场景OOM - zipkin分布式链路追踪项目之前采取zipkin做分布式链路追踪，后来换成skywalking，所以将zipkin相关配置和代码都移除了，但是忘记移除maven坐标了，运行一段时间后导致了频繁full gc，最后OOM了 因为配置了OOM后自动生成dump1文件，所以分析dump文件发现大对象是zipkin包里的ConcurrentHashMap$Node，通过观察zipkin的自动配置类ZipkinAutoConfiguration发现即使没有任何zipkin的配置，只要有zipkin的依赖都会创建一个异步报告者，默认的采样率为10%。所以即使不配置相关项，也会以默认采样率10%，发送到zipkin，这是默认的地址是http://localhost:9411/，此时发送到localhost:9411显然会被拒绝。导致堆中的异常实例堆积，从而OOM 123456private float probability = 0.1f;@ConfigurationProperties(&quot;spring.zipkin&quot;)public class ZipkinProperties &#123; private String baseUrl = &quot;http://localhost:9411/&quot;;&#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://boom-fzy.github.io/tags/JVM/"}]},{"title":"记录常用git命令","date":"2021-04-19T14:26:26.000Z","path":"2021/04/19/study-git/","text":"创建版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库 资源修改与提交123456789$ git status #查看资源状态$ git diff #查看变更内容$ git add . #所有改动的文件添加到暂存区$ git add &lt;file&gt; #指定的文件添加到暂存区$ git mv &lt;old&gt; &lt;new&gt; #文件修改名称$ git rm &lt;file&gt; #删除暂存区、分支、本地文件$ git rm --cached &lt;file&gt; #删除暂存区、分支文件$ git commit -m &quot;msg&quot; #提交所有更新过的文件$ git commit --amend #修改最后一次提交 撤销操作123$ git reset --hard HEAD #撤销工作目录所有未提交文件的修改内容$ git checkout HEAD &lt;file&gt; #撤销指定的未提交文件的修改内容$ git revert &lt;commit&gt; #撤销指定的提交 查看提交历史1234$ git log #查看提交历史$ git log -p &lt;file&gt; #查看指定文件的提交历史$ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史$ git show &lt;commit-id&gt; #查看某次提交的修改内容 分支与标签12345678910$ git branch #显示所有的分支$ git checkout &lt;branch&#x2F;tag&gt; #切换到指定分支或标签$ git branch &lt;new-branch&gt; #创建新的分支$ git branch -b &lt;new-branch&gt; #创建新的分支并切换到新分支$ git branch -d &lt;branch&gt; #删除本地分支$ git tag #列出所有本地标签$ git tag &lt;tag&gt; #基于最新提交创建标签$ git tag -d &lt;tag&gt; #删除标签$ git show &lt;tag&gt; #显示指定标签信息$ git tag -a &lt;tag&gt; -m &quot;msg&quot; #基于最新提交创建标签并添加注释 合并与衍合12345$ git merge &lt;branch&gt; #合并指定分支到当前分支$ git rebase &lt;branch&gt; #衍合指定分支到当前分支(线性历史)$ git cherry-pick &lt;commit-id&gt; #合并某次提交到当前分支$ git ls-files -s #检查文件是否发生合并冲突(0-没有冲突，合并成功，其他值为失败;1-共同版本文件内容;2-当前用户对应的文件版本;3-合并后的文件对应的远程版本)$ git show :n:filename #查看对应文件的对应版本的内容 远程操作123456789$ git remote -V #查看远程版本库信息$ git remote show &lt;remote&gt; #查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库$ git fetch &lt;remote&gt; #从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch&#x2F;tag&gt; #删除远程分支或标签$ git push origin --delete &lt;branch&gt; #删除远程分支$ git push --tags #上传所有标签","tags":[{"name":"git","slug":"git","permalink":"https://boom-fzy.github.io/tags/git/"}]},{"title":"记录ApachePIO导出excel时,createSheet()数组越界问题","date":"2021-04-18T13:53:31.000Z","path":"2021/04/18/prod-error-2021-04-19-1/","text":"异常介绍最近做了个功能,POI导出excel表格,在windows本地环境和Linux测试环境跑起来很正常,但是发现打包到生产环境Linux服务器上后,却一直报错: 然后检测代码,发现在createSheet()这里居然报数组越界异常！！！然后更换POI的版本，又检查生产环境Linux和测试Linux环境、windows的jdk版本是否一致，但是始终无法解决这个问题。最后发现是生产Linux环境的字体问题，缺少字体。 解决方案生产Linux环境重新安装系统字体库，重启应用，问题得到解决。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"ApachePOI","slug":"ApachePOI","permalink":"https://boom-fzy.github.io/tags/ApachePOI/"}]}]