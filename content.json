[{"title":"linux常用命令学习记录","date":"2021-08-30T11:28:25.000Z","path":"2021/08/30/linux-study/","text":"find path -option [-print] [-exec/-ok command ] {} ; 查找文件path: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print：find命令将匹配的文件输出到标准输出。-exec：find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和\\；之间的空格。-ok：和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 常用-option记录：-name filename #查找名为filename的文件-user username #按文件属主来查找-mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前-ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 chmod：修改权限chmod用于修改文件或者目录的权限。对于文件或者目录的普通权限，共有 3 种，分别为：r-读取，w-写入，x-执行还有 3 种特殊权限，分别为：suid-Set User ID，sgid-Set Group ID，sticky-粘滞位 文件及目录的权限范围，包括：u：User，即文件或目录的拥有者；g：Group，即文件或目录的所属群组；o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a：All，即全部的用户，包含拥有者、所属群组以及其他用户。 chmod -R 777 /softwarechmod -R u(+/-)r start.sh(注：+ : 添加权限，- : 回收权限) 权限的代号包括：r：读取权限，数字代号为4；w：写入权限，数字代号为2；x：执行或切换权限，数字代号为1；-：不具任何权限，数字代号为0；s：当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限。 $符号用法$0：获取shell脚本名称 $n: 获取shell脚本第n个参数的内容(注：n&gt;0，两位数以上须使用 {} 符号括住，如${10}) $?：上一指令的返回值，成功是0，不成功是1。 $*：shell脚本所有参数的内容 $@：基本上与上面相同。只不过是“$*”返回的是一个字符串，字符串中存在多外空格。 “$@”返回多个字符串。 $#：返回shell脚本参数的个数。 $$ :Shell本身的PID（ProcessID），即当前进程的PID。 $! ：Shell最后运行的后台Process的PID $- ：使用Set命令设定的Flag一览","tags":[{"name":"linux","slug":"linux","permalink":"https://boom-fzy.github.io/tags/linux/"}]},{"title":"JAVA线程池学习记录","date":"2021-08-04T12:58:51.000Z","path":"2021/08/04/threadPool/","text":"线程池的优势总体来说，线程池有如下的优势： （1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 （2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 （3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 线程池的创建如何创建一个线程池，Java中已经提供了创建线程池的一个类：Executor但是我们在创建线程池时，一般使用它的子类：ThreadPoolExecutor 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数说明：corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。 线程池工作原理 为什么不采用Executor创建线程池FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 LinkedBlockingQueue，可能会耗费非常大的内存，甚至 OOM。CachedThreadPool 和 ScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"threadPool","slug":"threadPool","permalink":"https://boom-fzy.github.io/tags/threadPool/"}]},{"title":"Git配置SSH Keys步骤","date":"2021-06-08T11:29:33.000Z","path":"2021/06/08/git-ssh/","text":"Git配置SSH Keys步骤许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。生成步骤如下： 1. 设置用户名和邮箱在git命令行中对git进行全局设置git config –global user.name “用户名” git config –global user.email “邮箱地址” 2. 生成SSH key在git命令行中，输入命令： cd ~/.ssh ，来检测是否生成过key,没有生成过key，会有相关信息提示 然后输入命令： ssh-keygen -t rsa -C “邮箱地址” ，按下回车键 然后根据返回的信息，找到.ssh目录下的两个文件 3. 在github上添加SSH key在github上点击“setting”，找到添加SSH key的菜单，然后新增SSH key 把文件 id_rsa.pub 里面的内容全部复制到 key 编辑框中，保存完毕 4. 检查SSH key是否有效在git命令行输入：ssh -T &#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d; ；这里会要求你输入SSH key密码，如果刚才生成SSH key时未输入密码，密码就为空；然后看到信息：ERROR: Hi 用户名! You’ve successfully authenticated；说明配置成功；","tags":[{"name":"git","slug":"git","permalink":"https://boom-fzy.github.io/tags/git/"}]},{"title":"数据库插入数据量过大时分批插入处理(JAVA)","date":"2021-05-18T09:27:11.000Z","path":"2021/05/18/essays-1/","text":"批处理原因1、一次性全部插入，mysql的sql语句是有最大长度限制的，默认是1M，可配置，超过最大长度就会报错。 2、一条条插入，数据传输多次，事务处理多次，会造成资源浪费。 解决方案1234567891011121314151617// 批次最大保存数量int batchNum = 500;// 总数据量int insertLength = list.size();int i = 0;while (insertLength &gt; batchNum) &#123; briefCntechRangesDataMapper.insertList(list.subList(i, i + batchNum)); i = i + batchNum; insertLength = insertLength - batchNum;&#125;// 保存首次或最后一次数据量不足&quot;批次最大保存数量&quot;的数据if (insertLength &gt; 0) &#123; briefCntechRangesDataMapper.insertList(list.subList(i, i + insertLength));&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在特殊情况下，比如插入的数据是业务表，每行的数据量较大，且该表访问频繁，那么，插入1条的时候可能不会锁表，而插入10000行的时候，会遇到锁表的情况。如果并发插入，甚至发生死锁。这个时候，就要根据经验分析，调整每个批次的量，以避免影响使用。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"}]},{"title":"class.forName()和ClassLoader.loadClass()的区别","date":"2021-05-17T14:46:11.000Z","path":"2021/05/17/study-1/","text":"区别Class.forName()执行初始化过程 执行静态代码化。ClassLoader.loadClass()不执行初始化过程。 解析Class.forName(className)源码： 123456@CallerSensitivepublic static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; Class.forName(className)方法，内部实际调用的方法是Class.forName(className,true,classloader);第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的static块代码执行，static参数也也会被再次初始化。 ClassLoader.loadClass(className)源码： 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125; ClassLoader.loadClass(className)方法，内部实际调用的方法是ClassLoader.loadClass(className,false);第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接。根据jvm类加载过程可知，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"}]},{"title":"Spring bean生命周期整理","date":"2021-04-27T11:33:38.000Z","path":"2021/04/27/study-spring-1/","text":"Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。本文将简短的介绍Spring Bean的生命周期。 Bean的生命周期如上图所示，Bean的生命周期还是比较复杂的，下面来对上图每一步骤做文字描述：&emsp; 1、spring启动，查找并加载需要被spring管理的bean，进行bean的实例化&emsp; 2、bean实例化后将bean的引入和值注入到bean的属性中&emsp; 3、如果bean实现了BeanNameAware接口的话，sping将bean的id传递给setBeanName()方法&emsp; 4、如果bean实现了BeanFactoryAware接口的话，spring将调用setBeanFactory()方法，将BeanFactory容器实例传入&emsp; 5、如果bean实现了ApplicationContextAware接口的话，spring将调用bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来&emsp; 6、如果bean实现了BeanPostProcessor接口，spring就将调用他们的postProcessBeforeInitialization()方法&emsp; 7、如果bean实现了InitialzingBean接口，spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-methd声明了初始化方法，该方法也会被调用&emsp; 8、如果bean实现了BeanPostProcessor接口，spring就将调用他们的postProcessAfterInitialization()方法&emsp; 9、此时，bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁&emsp; 10、如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method声明销毁方法，该方法也会被调用","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://boom-fzy.github.io/tags/Spring/"}]},{"title":"JAVA虚拟机-JVM学习随笔","date":"2021-04-26T12:59:45.000Z","path":"2021/04/26/study-JVM/","text":"JVM内存结构首先jvm结构分三部分：类装载器子系统，运行时数据区，执行引擎Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。每个区域都有各自的作用 运行时数据区程序寄存器、Java虚拟机栈、Java堆、方法区、运行时常量池、本地方法栈等 程序寄存器每个线程都拥有一个程序寄存器，是线程私有的，用来存储指向下一条指令的地址在创建线程的时候，创建相应的程序寄存器执行本地方法时，程序寄存器的值为 undefined是一块比较小的内存空间，是唯一一个在JVM规范中没有规定 OutOfMemoryError 的内存区域 Java栈栈由一系列帧（栈帧）（Frame）组成（因此Java栈也叫做帧栈），是线程私有的栈帧用来保存一个方法的局部变量、操作数栈（Java没有寄存器，所有参数传递使用操作数栈）、常量池指针、动态链接、方法返回等每一次方法调用创建一个帧，并压栈，退出方法的时候，修改栈顶指针就可以把栈帧中的内容销毁局部变量表存放了编译期可知的各种基本数据类型和引用类型，每个 slot 存放32位的数据，long、double、占两个槽位栈的优点： 存取速度比堆块，仅次于寄存器栈的缺点：存在栈中的数据大小、生存区是在编译器决定的，缺乏灵活性 Java堆用来存放应用系统创建的对象和数组，所有线程共享 Java 堆GC主要管理堆空间，对分代GC来说，堆也是分代的堆的优点：运行期动态分配内存大小，自动进行垃圾回收；堆的缺点：效率相对较慢 方法区方法区是线程共享的，通常用来保存装载的类的结构信息通常和元空间关联在一起，但具体的跟JVM实现和版本有关JVM规范把方法区描述为堆的一个逻辑部分，但它有一个别名称为 Non-heap（非堆），应是为了与 Java 堆分开 运行时常量池是Class文件中每个类或接口的常量池表，在运行期间的表示形式，通常包括：类的版本、字段、方法、接口等信息在方法区中分配通常在加载类和接口到JVM后，就创建相应的运行时常量池 本地方法栈在 JVM 中用来支持 native 方法执行的栈就是本地方法栈 GC 常用参数123456789101112131415161718192021-Xmn 年轻代-Xms 最小堆-Xmx 最大堆-Xss 栈空间-XX:+UseTLAB 使用TLAB(本地线程分配缓冲区)，默认打开-XX:+PrintTLAB 打印TLAB的使用情况-XX:TLABSize 设置TLAB大小-XX:+DisableExplictGC 禁用System.gc()不管用，防止FGC-XX:+PrintGC 打印GC日志-XX:+PrintGCDetails 打印GC详细日志信息-XX:+PrintHeapAtGC 打印GC前后的详细堆栈信息-XX:+PrintGCTimeStamps 打印时间戳-XX:+PrintGCApplicationConcurrentTime 打印应用程序时间-XX:+PrintGCApplicationStoppedTime 打印暂停时长-XX:+PrintReferenceGC 记录回收了多少种不同引用类型的引用-verbose:class 类加载详细过程-XX:+PrintVMOptions JVM参数-XX:+PrintFlagsFinal 查看JVM所有参数值-XX:+PrintFlagsInital 查看JVM参数启动的初始值-Xloggc:opt&#x2F;log&#x2F;gc.log GC日志的路径以及文件名称-XX:MaxTenuringThreshold 升代年龄，最大值15 垃圾收集器组合选择 单CPU或小内存，单机程序 -XX:+UseSerialGC 多CPU，需要最大吞吐量，如后台计算型应用 -XX:+UseParallelGC -XX:+UseParallelOldGC 多CPU，追求低停顿时间，需快速响应如互联网应用 -XX:+UseConcMarkSweepGC -XX:+ParNewGC table th { white-space: nowrap; padding-right: 10px; } table td:nth-child(1) { white-space: nowrap; } 参数 新生代垃圾收集器 新生代算法 老年代垃圾收集器 老年代算法 -XX:+UseSerialGC SerialGC 复制 SerialOldGC 标记-整理 -XX:+UseParallelGC ParNew 复制 SerialOldGC 标记-整理 -XX:+UseParallelGC-XX:UseParallelOldGC Parallel[Scavenge] 复制 SerialOldGC 标记-整理 -XX:+UseConcMarkSweepGC ParNew 复制 SerialOldGC 标记-整理 -XX:+UseG1GC G1整体上采用标记-整理算法 局部通过复制算法，不会产生内存碎片 CMS+SerialOldGC的收集器组合，SerialOldGC作为CMS出错的后备垃圾收集器 标记-清除 系统CPU经常100%，如何调优CPU100%，那肯定是有线程一直在占用着系统资源，所以具体方法如下： 1、找出哪个进程cpu占用高 (top 命名)2、该进程中的哪个线程cpu占用高 (top -Hp $pid 命令)3、将十进制的tid转化为十六进制 (printf %x $tid 命令)4、导出该线程的堆栈 (jstack $pid &gt; $pid.log 命令)5、查找哪个方法(栈帧)消耗时间 (less $pid.log)6、可以确认工作线程占比高还是垃圾回收线程占比高7、修改代码 实际调优场景OOM - zipkin分布式链路追踪项目之前采取zipkin做分布式链路追踪，后来换成skywalking，所以将zipkin相关配置和代码都移除了，但是忘记移除maven坐标了，运行一段时间后导致了频繁full gc，最后OOM了 因为配置了OOM后自动生成dump1文件，所以分析dump文件发现大对象是zipkin包里的ConcurrentHashMap$Node，通过观察zipkin的自动配置类ZipkinAutoConfiguration发现即使没有任何zipkin的配置，只要有zipkin的依赖都会创建一个异步报告者，默认的采样率为10%。所以即使不配置相关项，也会以默认采样率10%，发送到zipkin，这是默认的地址是http://localhost:9411/，此时发送到localhost:9411显然会被拒绝。导致堆中的异常实例堆积，从而OOM 123456private float probability = 0.1f;@ConfigurationProperties(&quot;spring.zipkin&quot;)public class ZipkinProperties &#123; private String baseUrl = &quot;http://localhost:9411/&quot;;&#125;","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://boom-fzy.github.io/tags/JVM/"}]},{"title":"记录常用git命令","date":"2021-04-19T14:26:26.000Z","path":"2021/04/19/study-git/","text":"创建版本库12$ git clone &lt;url&gt; #克隆远程版本库$ git init #初始化本地版本库 资源修改与提交123456789$ git status #查看资源状态$ git diff #查看变更内容$ git add . #所有改动的文件添加到暂存区$ git add &lt;file&gt; #指定的文件添加到暂存区$ git mv &lt;old&gt; &lt;new&gt; #文件修改名称$ git rm &lt;file&gt; #删除暂存区、分支、本地文件$ git rm --cached &lt;file&gt; #删除暂存区、分支文件$ git commit -m &quot;msg&quot; #提交所有更新过的文件$ git commit --amend #修改最后一次提交 撤销操作123$ git reset --hard HEAD #撤销工作目录所有未提交文件的修改内容$ git checkout HEAD &lt;file&gt; #撤销指定的未提交文件的修改内容$ git revert &lt;commit&gt; #撤销指定的提交 查看提交历史1234$ git log #查看提交历史$ git log -p &lt;file&gt; #查看指定文件的提交历史$ git blame &lt;file&gt; #以列表方式查看指定文件的提交历史$ git show &lt;commit-id&gt; #查看某次提交的修改内容 分支与标签12345678910$ git branch #显示所有的分支$ git checkout &lt;branch&#x2F;tag&gt; #切换到指定分支或标签$ git branch &lt;new-branch&gt; #创建新的分支$ git checkout -b &lt;new-branch&gt; #创建新的分支并切换到新分支$ git branch -d &lt;branch&gt; #删除本地分支$ git tag #列出所有本地标签$ git tag &lt;tag&gt; #基于最新提交创建标签$ git tag -d &lt;tag&gt; #删除标签$ git show &lt;tag&gt; #显示指定标签信息$ git tag -a &lt;tag&gt; -m &quot;msg&quot; #基于最新提交创建标签并添加注释 合并与衍合12345$ git merge &lt;branch&gt; #合并指定分支到当前分支$ git rebase &lt;branch&gt; #衍合指定分支到当前分支(线性历史)$ git cherry-pick &lt;commit-id&gt; #合并某次提交到当前分支$ git ls-files -s #检查文件是否发生合并冲突(0-没有冲突，合并成功，其他值为失败;1-共同版本文件内容;2-当前用户对应的文件版本;3-合并后的文件对应的远程版本)$ git show :n:filename #查看对应文件的对应版本的内容 远程操作123456789$ git remote -v #查看远程版本库信息$ git remote show &lt;remote&gt; #查看指定远程版本库信息$ git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库$ git fetch &lt;remote&gt; #从远程库获取代码$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并$ git push &lt;remote&gt; :&lt;branch&#x2F;tag&gt; #删除远程分支或标签$ git push origin --delete &lt;branch&gt; #删除远程分支$ git push --tags #上传所有标签","tags":[{"name":"git","slug":"git","permalink":"https://boom-fzy.github.io/tags/git/"}]},{"title":"记录ApachePIO导出excel时,createSheet()数组越界问题","date":"2021-04-18T13:53:31.000Z","path":"2021/04/18/prod-error-2021-04-19-1/","text":"异常介绍最近做了个功能,POI导出excel表格,在windows本地环境和Linux测试环境跑起来很正常,但是发现打包到生产环境Linux服务器上后,却一直报错: 然后检测代码,发现在createSheet()这里居然报数组越界异常！！！然后更换POI的版本，又检查生产环境Linux和测试Linux环境、windows的jdk版本是否一致，但是始终无法解决这个问题。最后发现是生产Linux环境的字体问题，缺少字体。 解决方案生产Linux环境重新安装系统字体库，重启应用，问题得到解决。","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://boom-fzy.github.io/tags/JAVA/"},{"name":"ApachePOI","slug":"ApachePOI","permalink":"https://boom-fzy.github.io/tags/ApachePOI/"}]}]